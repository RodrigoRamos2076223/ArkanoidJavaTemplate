<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Brick.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Brick.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public abstract class Brick {&#10;    protected Animator animator;&#10;    protected int posX, posY;&#10;    protected Rectangle boundingBox;&#10;    protected boolean collided = false;&#10;&#10;    // compatibility constructor (single-frame sprite)&#10;    public Brick(SpriteBatch batch, String spritePath) {&#10;        this(batch, spritePath, 2,1,0,0); // inicializa temporariamente em (0,0)&#10;    }&#10;&#10;    // sprite-sheet aware constructor&#10;    public Brick(SpriteBatch batch, String spritePath, int cols, int rows, int x, int y){&#10;        this.animator = new Animator(batch, spritePath, cols, rows);&#10;        this.posX = x;&#10;        this.posY = y;&#10;        // initialize animator and bounding box immediately&#10;        animator.create();&#10;        int w = Math.max(1, animator.getWidth());&#10;        int h = Math.max(1, animator.getHeight());&#10;        this.boundingBox = new Rectangle(posX, posY, w, h);&#10;    }&#10;&#10;    // Renderiza o brick no ecrã&#10;    public void render() {&#10;        if (boundingBox != null) {&#10;            animator.render(posX, posY, (int) boundingBox.width, (int) boundingBox.height);&#10;        } else {&#10;            animator.render(posX, posY);&#10;        }&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public int getPosX() { return posX; }&#10;    public int getPosY() { return posY; }&#10;&#10;    public boolean isCollided() {&#10;        return collided;&#10;    }&#10;&#10;    // Cada tipo de brick implementa o comportamento da colisão&#10;    public abstract void onCollision();&#10;&#10;    // Pontos obtidos ao destruir este brick (subclasses podem sobrescrever)&#10;    public int getPoints() { return 0; }&#10;}" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public abstract class Brick {&#10;    protected Animator animator;&#10;    protected int posX, posY;&#10;    protected Rectangle boundingBox;&#10;    protected boolean collided = false;&#10;&#10;    // compatibility constructor (single-frame sprite)&#10;    public Brick(SpriteBatch batch, String spritePath) {&#10;        this(batch, spritePath, 2,1,0,0); // inicializa temporariamente em (0,0)&#10;    }&#10;&#10;    // sprite-sheet aware constructor&#10;    public Brick(SpriteBatch batch, String spritePath, int cols, int rows, int x, int y){&#10;        this.animator = new Animator(batch, spritePath, cols, rows);&#10;        this.posX = x;&#10;        this.posY = y;&#10;        // initialize animator and bounding box immediately&#10;        animator.create();&#10;        int w = Math.max(1, animator.getWidth());&#10;        int h = Math.max(1, animator.getHeight());&#10;        this.boundingBox = new Rectangle(posX, posY, w, h);&#10;    }&#10;&#10;    // Renderiza o brick no ecrã&#10;    public void render() {&#10;        if (boundingBox != null) {&#10;            animator.render(posX, posY, (int) boundingBox.width, (int) boundingBox.height);&#10;        } else {&#10;            animator.render(posX, posY);&#10;        }&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public int getPosX() { return posX; }&#10;    public int getPosY() { return posY; }&#10;&#10;    public boolean isCollided() {&#10;        return collided;&#10;    }&#10;&#10;    // Cada tipo de brick implementa o comportamento da colisão&#10;    public abstract void onCollision();&#10;&#10;    // Pontos obtidos ao destruir este brick (subclasses podem sobrescrever)&#10;    public int getPoints() { return 0; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/BrickGrid.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/BrickGrid.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Random;&#10;&#10;public class BrickGrid {&#10;&#10;    private final List&lt;Brick&gt; bricks;&#10;    private final List&lt;Explosion&gt; explosions;&#10;    private final List&lt;PowerUp&gt; powerUps;&#10;    private final SpriteBatch batch;&#10;    private int score = 0; // contador simples de pontos&#10;&#10;    private static final int ROWS = 4;&#10;    private static final int COLS = 20;&#10;&#10;    public BrickGrid(SpriteBatch batch) {&#10;        this.batch = batch;&#10;        this.bricks = new ArrayList&lt;&gt;();&#10;        this.explosions = new ArrayList&lt;&gt;();&#10;        this.powerUps = new ArrayList&lt;&gt;();&#10;        createBricks();&#10;    }&#10;&#10;    private void createBricks() {&#10;        Random rng = new Random();&#10;&#10;        int brickW = 32;&#10;        int brickH = 16;&#10;        int spacingX = 20;&#10;        int spacingY = 13;&#10;&#10;        int totalWidth = COLS * (brickW + spacingX) - spacingX;&#10;        int startX = (Gdx.graphics.getWidth() - totalWidth) / 2;&#10;        int startY = Gdx.graphics.getHeight() - 100;&#10;&#10;        bricks.clear();&#10;&#10;        for (int row = 0; row &lt; ROWS; row++) {&#10;            for (int col = 0; col &lt; COLS; col++) {&#10;                float p = rng.nextFloat();&#10;                Brick b;&#10;&#10;                if (p &lt; 0.5f) {&#10;                    b = new NormalBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.8f) {&#10;                    b = new StrongBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.9f) {&#10;                    b = new IndestructibleBrick(batch, 0, 0);&#10;                } else {&#10;                    b = new PowerUpBrick(batch, 0, 0);&#10;                }&#10;&#10;                int x = startX + col * (brickW + spacingX);&#10;                int y = startY - row * (brickH + spacingY);&#10;&#10;                b.posX = x;&#10;                b.posY = y;&#10;                b.getBoundingBox().setPosition(x, y);&#10;&#10;                bricks.add(b);&#10;            }&#10;        }&#10;    }&#10;&#10;    /** Atualiza colisões e explosões */&#10;    // Nota: recebe Player para processar colisões com powerups&#10;    public void update(float delta, Ball ball, Player player) {&#10;        // Checa colisões entre bola e bricks usando um ciclo indexado (reverse) para permitir remoção&#10;        for (int i = bricks.size() - 1; i &gt;= 0; i--) {&#10;            Brick brick = bricks.get(i);&#10;            if (brick.getBoundingBox().overlaps(ball.getBoundingBox())) {&#10;                // processa colisão&#10;                brick.onCollision();&#10;&#10;                // inverte a direção da bola uma vez por colisão&#10;                ball.reverseYDirection();&#10;                // empurra a bola para fora do brick para evitar colisões repetidas&#10;&#10;                // se o brick foi destruído com este impacto, cria explosão e remove o brick&#10;                if (brick.isCollided()) {&#10;                    // incrementa pontuação conforme o tipo de brick&#10;                    score += brick.getPoints();&#10;&#10;                    int explosionX = brick.getPosX();&#10;                    int explosionY = brick.getPosY();&#10;                    int w = (int) brick.getBoundingBox().width;&#10;                    int h = (int) brick.getBoundingBox().height;&#10;                    explosions.add(new Explosion(batch, explosionX, explosionY, w, h));&#10;&#10;                    // se for PowerUpBrick, cria um PowerUp a cair&#10;                    if (brick instanceof PowerUpBrick) {&#10;                        PowerUp.Type[] vals = PowerUp.Type.values();&#10;                        PowerUp.Type t = vals[(int) (Math.random() * vals.length)];&#10;                        PowerUp pu = new PowerUp(batch, brick.getPosX(), brick.getPosY(), t);&#10;                        powerUps.add(pu);&#10;                    }&#10;&#10;                    bricks.remove(i);&#10;                }&#10;&#10;                // processa apenas a primeira colisão desta frame.&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Atualiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.update(delta);&#10;        }&#10;&#10;        // Remove explosões concluídas&#10;        explosions.removeIf(Explosion::shouldRemove);&#10;&#10;        // Atualiza powerups e checa colisão com o player&#10;        for (PowerUp pu : powerUps) {&#10;            pu.update(delta);&#10;            if (pu.getBoundingBox().overlaps(player.getBoundingBox())) {&#10;                 if (pu.getType() == PowerUp.Type.FAST_PADDLE) {&#10;                    player.increaseSpeed();&#10;                } else if (pu.getType() == PowerUp.Type.FAST_BALL) {&#10;                    ball.increaseSpeedY();&#10;                }&#10;                pu.markForRemove();&#10;            }&#10;        }&#10;&#10;        // Remove powerups que caíram ou foram apanhados&#10;        powerUps.removeIf(PowerUp::shouldRemove);&#10;    }&#10;&#10;    /** Renderiza bricks e explosões */&#10;    public void render() {&#10;        // Renderiza bricks ainda não destruídos&#10;        for (Brick brick : bricks) {&#10;            if (!brick.isCollided()) {&#10;                brick.render();&#10;            }&#10;        }&#10;&#10;        // Renderiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.render();&#10;        }&#10;&#10;        // Renderiza powerups&#10;        for (PowerUp pu : powerUps) {&#10;            pu.render();&#10;        }&#10;    }&#10;&#10;    // Retorna a pontuação atual&#10;    public int getScore() { return score; }&#10;}" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Random;&#10;&#10;public class BrickGrid {&#10;&#10;    private final List&lt;Brick&gt; bricks;&#10;    private final List&lt;Explosion&gt; explosions;&#10;    private final List&lt;PowerUp&gt; powerUps;&#10;    private final SpriteBatch batch;&#10;    private int score = 0; // contador simples de pontos&#10;&#10;    private static final int ROWS = 4;&#10;    private static final int COLS = 20;&#10;&#10;    public BrickGrid(SpriteBatch batch) {&#10;        this.batch = batch;&#10;        this.bricks = new ArrayList&lt;&gt;();&#10;        this.explosions = new ArrayList&lt;&gt;();&#10;        this.powerUps = new ArrayList&lt;&gt;();&#10;        createBricks();&#10;    }&#10;&#10;    private void createBricks() {&#10;        Random rng = new Random();&#10;&#10;        int brickW = 32;&#10;        int brickH = 16;&#10;        int spacingX = 20;&#10;        int spacingY = 13;&#10;&#10;        int totalWidth = COLS * (brickW + spacingX) - spacingX;&#10;        int startX = (Gdx.graphics.getWidth() - totalWidth) / 2;&#10;        int startY = Gdx.graphics.getHeight() - 100;&#10;&#10;        bricks.clear();&#10;&#10;        for (int row = 0; row &lt; ROWS; row++) {&#10;            for (int col = 0; col &lt; COLS; col++) {&#10;                float p = rng.nextFloat();&#10;                Brick b;&#10;&#10;                if (p &lt; 0.5f) {&#10;                    b = new NormalBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.8f) {&#10;                    b = new StrongBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.9f) {&#10;                    b = new IndestructibleBrick(batch, 0, 0);&#10;                } else {&#10;                    b = new PowerUpBrick(batch, 0, 0);&#10;                }&#10;&#10;                int x = startX + col * (brickW + spacingX);&#10;                int y = startY - row * (brickH + spacingY);&#10;&#10;                b.posX = x;&#10;                b.posY = y;&#10;                b.getBoundingBox().setPosition(x, y);&#10;&#10;                bricks.add(b);&#10;            }&#10;        }&#10;    }&#10;&#10;    /** Atualiza colisões e explosões */&#10;    // Nota: recebe Player para processar colisões com powerups&#10;    public void update(float delta, Ball ball, Player player) {&#10;        // Checa colisões entre bola e bricks usando um ciclo indexado (reverse) para permitir remoção&#10;        for (int i = bricks.size() - 1; i &gt;= 0; i--) {&#10;            Brick brick = bricks.get(i);&#10;            if (brick.getBoundingBox().overlaps(ball.getBoundingBox())) {&#10;                // processa colisão&#10;                brick.onCollision();&#10;&#10;                // inverte a direção da bola uma vez por colisão&#10;                ball.reverseYDirection();&#10;                // empurra a bola para fora do brick para evitar colisões repetidas&#10;&#10;                // se o brick foi destruído com este impacto, cria explosão e remove o brick&#10;                if (brick.isCollided()) {&#10;                    // incrementa pontuação conforme o tipo de brick&#10;                    score += brick.getPoints();&#10;&#10;                    int explosionX = brick.getPosX();&#10;                    int explosionY = brick.getPosY();&#10;                    int w = (int) brick.getBoundingBox().width;&#10;                    int h = (int) brick.getBoundingBox().height;&#10;                    explosions.add(new Explosion(batch, explosionX, explosionY, w, h));&#10;&#10;                    // se for PowerUpBrick, cria um PowerUp a cair&#10;                    if (brick instanceof PowerUpBrick) {&#10;                        PowerUp.Type[] vals = PowerUp.Type.values();&#10;                        PowerUp.Type t = vals[(int) (Math.random() * vals.length)];&#10;                        PowerUp pu = new PowerUp(batch, brick.getPosX(), brick.getPosY(), t);&#10;                        powerUps.add(pu);&#10;                    }&#10;&#10;                    bricks.remove(i);&#10;                }&#10;&#10;                // processa apenas a primeira colisão desta frame.&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Atualiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.update(delta);&#10;        }&#10;&#10;        // Remove explosões concluídas&#10;        explosions.removeIf(Explosion::shouldRemove);&#10;&#10;        // Atualiza powerups e checa colisão com o player&#10;        for (PowerUp pu : powerUps) {&#10;            pu.update(delta);&#10;            if (pu.getBoundingBox().overlaps(player.getBoundingBox())) {&#10;                 if (pu.getType() == PowerUp.Type.FAST_PADDLE) {&#10;                    player.increaseSpeed();&#10;                } else if (pu.getType() == PowerUp.Type.FAST_BALL) {&#10;                    ball.increaseSpeedY();&#10;                }&#10;                pu.markForRemove();&#10;            }&#10;        }&#10;&#10;        // Remove powerups que caíram ou foram apanhados&#10;        powerUps.removeIf(PowerUp::shouldRemove);&#10;    }&#10;&#10;    /** Renderiza bricks e explosões */&#10;    public void render() {&#10;        // Renderiza bricks ainda não destruídos&#10;        for (Brick brick : bricks) {&#10;            if (!brick.isCollided()) {&#10;                brick.render();&#10;            }&#10;        }&#10;&#10;        // Renderiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.render();&#10;        }&#10;&#10;        // Renderiza powerups&#10;        for (PowerUp pu : powerUps) {&#10;            pu.render();&#10;        }&#10;    }&#10;&#10;    // Retorna a pontuação atual&#10;    public int getScore() { return score; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/NormalBrick.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/NormalBrick.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;public class NormalBrick extends Brick {&#10;&#10;    private int points = 10;&#10;&#10;&#10;    public NormalBrick(SpriteBatch batch, int x, int y) {&#10;        // Usar yellow.png como spritesheet (assumido 4 colunas x 1 linha)&#10;        super(batch, &quot;yellow.png&quot;, 2, 1, x, y);&#10;    }&#10;&#10;    @Override&#10;    public void onCollision() {&#10;        collided= true;&#10;    }&#10;&#10;    @Override&#10;    public int getPoints() { return 10; }&#10;&#10;}" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;public class NormalBrick extends Brick {&#10;&#10;    private int points = 10;&#10;&#10;&#10;    public NormalBrick(SpriteBatch batch, int x, int y) {&#10;        // Usar yellow.png como spritesheet (assumido 4 colunas x 1 linha)&#10;        super(batch, &quot;yellow.png&quot;, 2, 1, x, y);&#10;    }&#10;&#10;    @Override&#10;    public void onCollision() {&#10;        collided= true;&#10;    }&#10;&#10;    @Override&#10;    public int getPoints() { return 10; }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/PowerUp.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/PowerUp.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public class PowerUp {&#10;    public enum Type {FAST_PADDLE, FAST_BALL }&#10;&#10;    private final Animator animator;&#10;    private int x, y;&#10;    private final Rectangle boundingBox;&#10;    private final Type type;&#10;    private boolean remove = false;&#10;    private float fallSpeed = 3; // velocidade inicial a cair&#10;&#10;    public PowerUp(SpriteBatch batch, int x, int y, Type type) {&#10;        this.animator = new Animator(batch, &quot;ship.png&quot;, 5, 2);&#10;        animator.create();&#10;        this.x = x;&#10;        this.y = y;&#10;        this.type = type;&#10;        int w = animator.getWidth();&#10;        int h = animator.getHeight();&#10;        this.boundingBox = new Rectangle(x, y, w, h);&#10;    }&#10;&#10;    public void update(float delta) {&#10;        // simples movimento descendente&#10;        y -= fallSpeed;&#10;        boundingBox.setPosition(x, y);&#10;    }&#10;&#10;    public void render() {&#10;        if (remove) return;&#10;        animator.render(x, y);&#10;    }&#10;&#10;    public Rectangle getBoundingBox() { return boundingBox; }&#10;&#10;    public Type getType() { return type; }&#10;&#10;    public void markForRemove() { remove = true; }&#10;&#10;    public boolean shouldRemove() { return remove || y + boundingBox.height &lt; 0; }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public class PowerUp {&#10;    public enum Type {FAST_PADDLE, FAST_BALL }&#10;&#10;    private final Animator animator;&#10;    private int x, y;&#10;    private final Rectangle boundingBox;&#10;    private final Type type;&#10;    private boolean remove = false;&#10;    private float fallSpeed = 3; // velocidade inicial a cair&#10;&#10;    public PowerUp(SpriteBatch batch, int x, int y, Type type) {&#10;        this.animator = new Animator(batch, &quot;ship.png&quot;, 5, 2);&#10;        animator.create();&#10;        this.x = x;&#10;        this.y = y;&#10;        this.type = type;&#10;        int w = animator.getWidth();&#10;        int h = animator.getHeight();&#10;        this.boundingBox = new Rectangle(x, y, w, h);&#10;    }&#10;&#10;    public void update(float delta) {&#10;        // simples movimento descendente&#10;        y -= fallSpeed;&#10;        boundingBox.setPosition(x, y);&#10;    }&#10;&#10;    public void render() {&#10;        if (remove) return;&#10;        animator.render(x, y);&#10;    }&#10;&#10;    public Rectangle getBoundingBox() { return boundingBox; }&#10;&#10;    public Type getType() { return type; }&#10;&#10;    public void markForRemove() { remove = true; }&#10;&#10;    public boolean shouldRemove() { return remove || y + boundingBox.height &lt; 0; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/StrongBrick.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/StrongBrick.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;public class StrongBrick extends Brick {&#10;&#10;    private int lives = 2;&#10;&#10;&#10;    public StrongBrick(SpriteBatch batch, int x, int y) {&#10;        // usa constructor que permite indicar o spritesheet (assumido 4 colunas x 1 linha)&#10;        super(batch, &quot;red.png&quot;, 2, 1, x, y);&#10;    }&#10;&#10;    @Override&#10;    public void onCollision() {&#10;        lives--;&#10;        if (lives &lt;= 0) {&#10;            collided = true;&#10;        }&#10;&#10;    }&#10;&#10;    @Override&#10;    public int getPoints() { return 20; }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;public class StrongBrick extends Brick {&#10;&#10;    private int lives = 2;&#10;&#10;&#10;    public StrongBrick(SpriteBatch batch, int x, int y) {&#10;        // usa constructor que permite indicar o spritesheet (assumido 4 colunas x 1 linha)&#10;        super(batch, &quot;red.png&quot;, 2, 1, x, y);&#10;    }&#10;&#10;    @Override&#10;    public void onCollision() {&#10;        lives--;&#10;        if (lives &lt;= 0) {&#10;            collided = true;&#10;        }&#10;&#10;    }&#10;&#10;    @Override&#10;    public int getPoints() { return 20; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Animator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Animator.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.Animation;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;&#10;public class Animator {&#10;&#10;    // Constant rows and columns of the sprite sheet&#10;    private int FRAME_COLS, FRAME_ROWS;&#10;    // Objects used&#10;    private Animation&lt;TextureRegion&gt; walkAnimation; // Must declare frame type (TextureRegion)&#10;    private Texture walkSheet;&#10;    private SpriteBatch spriteBatch;&#10;    private String path;&#10;    private int width, height;&#10;&#10;    // A variable for tracking elapsed time for the animation&#10;    float stateTime;&#10;&#10;    public Animator(SpriteBatch batch, String path, int columns, int rows) {&#10;        this.spriteBatch = batch;&#10;        this.FRAME_COLS = columns;&#10;        this.FRAME_ROWS = rows;&#10;        this.path = path;&#10;    }&#10;&#10;    public void create() {&#10;&#10;        // Load the sprite sheet as a Texture&#10;        walkSheet = new Texture(Gdx.files.internal(path));&#10;        // Use the split utility method to create a 2D array of TextureRegions. This is&#10;        // possible because this sprite sheet contains frames of equal size and they are&#10;        // all aligned.&#10;        this.width = walkSheet.getWidth() / FRAME_COLS;&#10;        this.height = walkSheet.getHeight() / FRAME_ROWS;&#10;&#10;        TextureRegion[][] tmp = TextureRegion.split(walkSheet,&#10;                walkSheet.getWidth() / FRAME_COLS,&#10;                walkSheet.getHeight() / FRAME_ROWS);&#10;&#10;        // Place the regions into a 1D array in the correct order, starting from the top&#10;        // left, going across first. The Animation constructor requires a 1D array.&#10;        TextureRegion[] walkFrames = new TextureRegion[FRAME_COLS * FRAME_ROWS];&#10;        int index = 0;&#10;        for (int i = 0; i &lt; FRAME_ROWS; i++) {&#10;            for (int j = 0; j &lt; FRAME_COLS; j++) {&#10;                walkFrames[index++] = tmp[i][j];&#10;            }&#10;        }&#10;&#10;        // Initialize the Animation with the frame interval and array of frames&#10;        walkAnimation = new Animation&lt;&gt;(0.095f, walkFrames);&#10;        // time to 0&#10;        stateTime = 0f;&#10;    }&#10;&#10;&#10;    public void render(int posX, int posY) {&#10;        stateTime += Gdx.graphics.getDeltaTime(); // Accumulate elapsed animation time&#10;        // Get current frame of animation for the current stateTime&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY); // Draw current frame at (50, 50)&#10;    }&#10;&#10;    // Overloaded render that scales the frame to provided width/height&#10;    public void render(int posX, int posY, int drawWidth, int drawHeight) {&#10;        stateTime += Gdx.graphics.getDeltaTime();&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY, drawWidth, drawHeight);&#10;    }&#10;&#10;&#10;    public void dispose() { // SpriteBatches and Textures must always be disposed&#10;        walkSheet.dispose();&#10;    }&#10;&#10;    public int getHeight() {&#10;        return height;&#10;    }&#10;&#10;    public int getWidth() {&#10;        return width;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.Animation;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;&#10;public class Animator {&#10;&#10;    // Constant rows and columns of the sprite sheet&#10;    private int FRAME_COLS, FRAME_ROWS;&#10;    // Objects used&#10;    private Animation&lt;TextureRegion&gt; walkAnimation; // Must declare frame type (TextureRegion)&#10;    private Texture walkSheet;&#10;    private SpriteBatch spriteBatch;&#10;    private String path;&#10;    private int width, height;&#10;&#10;    // A variable for tracking elapsed time for the animation&#10;    float stateTime;&#10;&#10;    public Animator(SpriteBatch batch, String path, int columns, int rows) {&#10;        this.spriteBatch = batch;&#10;        this.FRAME_COLS = columns;&#10;        this.FRAME_ROWS = rows;&#10;        this.path = path;&#10;    }&#10;&#10;    public void create() {&#10;&#10;        // Load the sprite sheet as a Texture&#10;        walkSheet = new Texture(Gdx.files.internal(path));&#10;        // Use the split utility method to create a 2D array of TextureRegions. This is&#10;        // possible because this sprite sheet contains frames of equal size and they are&#10;        // all aligned.&#10;        this.width = walkSheet.getWidth() / FRAME_COLS;&#10;        this.height = walkSheet.getHeight() / FRAME_ROWS;&#10;&#10;        TextureRegion[][] tmp = TextureRegion.split(walkSheet,&#10;                walkSheet.getWidth() / FRAME_COLS,&#10;                walkSheet.getHeight() / FRAME_ROWS);&#10;&#10;        // Place the regions into a 1D array in the correct order, starting from the top&#10;        // left, going across first. The Animation constructor requires a 1D array.&#10;        TextureRegion[] walkFrames = new TextureRegion[FRAME_COLS * FRAME_ROWS];&#10;        int index = 0;&#10;        for (int i = 0; i &lt; FRAME_ROWS; i++) {&#10;            for (int j = 0; j &lt; FRAME_COLS; j++) {&#10;                walkFrames[index++] = tmp[i][j];&#10;            }&#10;        }&#10;&#10;        // Initialize the Animation with the frame interval and array of frames&#10;        walkAnimation = new Animation&lt;&gt;(0.095f, walkFrames);&#10;        // time to 0&#10;        stateTime = 0f;&#10;    }&#10;&#10;&#10;    public void render(int posX, int posY) {&#10;        stateTime += Gdx.graphics.getDeltaTime(); // Accumulate elapsed animation time&#10;        // Get current frame of animation for the current stateTime&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY); // Draw current frame at (50, 50)&#10;    }&#10;&#10;    // Overloaded render that scales the frame to provided width/height&#10;    public void render(int posX, int posY, int drawWidth, int drawHeight) {&#10;        stateTime += Gdx.graphics.getDeltaTime();&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY, drawWidth, drawHeight);&#10;    }&#10;&#10;&#10;    public void dispose() { // SpriteBatches and Textures must always be disposed&#10;        walkSheet.dispose();&#10;    }&#10;&#10;    public int getHeight() {&#10;        return height;&#10;    }&#10;&#10;    public int getWidth() {&#10;        return width;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Game.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Game.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.ApplicationAdapter;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.BitmapFont;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import pt.uma.tpsi.ad.entities.Ball;&#10;import pt.uma.tpsi.ad.entities.BrickGrid;&#10;import pt.uma.tpsi.ad.entities.Player;&#10;&#10;public class Game extends ApplicationAdapter {&#10;    private SpriteBatch batch;&#10;    private BackgroundManagement backgroundManagement;&#10;    private BitmapFont font;&#10;    private Player player;&#10;    private Ball ball;&#10;    private BrickGrid brickGrid;&#10;&#10;    private boolean gameOver = false; // controla o fim do jogo&#10;&#10;    @Override&#10;    public void create() {&#10;        Gdx.graphics.setWindowedMode(1280, 720);&#10;        Gdx.graphics.setForegroundFPS(60);&#10;        batch = new SpriteBatch();&#10;&#10;        backgroundManagement = new BackgroundManagement(batch);&#10;        player = new Player(batch);&#10;        player.create();&#10;&#10;        ball = new Ball(batch);&#10;        ball.create();&#10;        brickGrid = new BrickGrid(batch);&#10;&#10;        //  Usa a fonte padrão do LibGDX — sem precisar de ficheiros externos&#10;        font = new BitmapFont();&#10;    }&#10;&#10;    @Override&#10;    public void render() {&#10;        batch.begin();&#10;        backgroundManagement.render();&#10;        player.render();&#10;        ball.render();&#10;        // Atualiza bricks/explosões e processa colisões dentro do BrickGrid&#10;        float delta = Gdx.graphics.getDeltaTime();&#10;        brickGrid.update(delta, ball, player);&#10;        // depois desenha a grelha atualizada&#10;        brickGrid.render();&#10;&#10;        if (ball.getBoundingBox().overlaps(player.getBoundingBox())) {&#10;            // ajusta direção horizontal consoante o ponto de contacto com o paddle&#10;            ball.adjustDirectionOnContact(player.getBoundingBox());&#10;            ball.reverseYDirection(); // faz a bola “saltar” para cima&#10;        }&#10;&#10;        // Se o jogo ainda não acabou, atualiza normalmente&#10;        if (!gameOver) {&#10;            if (ball.posY() &lt; 0) { // se a bola sair por baixo do ecrã&#10;                gameOver = true;&#10;            }&#10;        }&#10;&#10;        // Se o jogo acabou, mostra o texto no ecrã&#10;        if (gameOver) {&#10;            font.getData().setScale(3); // aumenta o tamanho do texto&#10;            font.draw(batch, &quot;GAME OVER&quot;,&#10;                Gdx.graphics.getWidth() / 2f - 150,&#10;                Gdx.graphics.getHeight() / 2f);&#10;        }&#10;&#10;        // Desenha pontuação no canto superior esquerdo&#10;        font.getData().setScale(1.2f);&#10;        font.draw(batch, &quot;Points: &quot; + brickGrid.getScore(), 10, Gdx.graphics.getHeight() - 10);&#10;&#10;        batch.end();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        font.dispose();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.ApplicationAdapter;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.BitmapFont;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import pt.uma.tpsi.ad.entities.Ball;&#10;import pt.uma.tpsi.ad.entities.BrickGrid;&#10;import pt.uma.tpsi.ad.entities.Player;&#10;&#10;public class Game extends ApplicationAdapter {&#10;    private SpriteBatch batch;&#10;    private BackgroundManagement backgroundManagement;&#10;    private BitmapFont font;&#10;    private Player player;&#10;    private Ball ball;&#10;    private BrickGrid brickGrid;&#10;&#10;    private boolean gameOver = false; // controla o fim do jogo&#10;&#10;    @Override&#10;    public void create() {&#10;        Gdx.graphics.setWindowedMode(1280, 720);&#10;        Gdx.graphics.setForegroundFPS(60);&#10;        batch = new SpriteBatch();&#10;&#10;        backgroundManagement = new BackgroundManagement(batch);&#10;        player = new Player(batch);&#10;        player.create();&#10;&#10;        ball = new Ball(batch);&#10;        ball.create();&#10;        brickGrid = new BrickGrid(batch);&#10;&#10;        //  Usa a fonte padrão do LibGDX — sem precisar de ficheiros externos&#10;        font = new BitmapFont();&#10;    }&#10;&#10;    @Override&#10;    public void render() {&#10;        batch.begin();&#10;        backgroundManagement.render();&#10;        player.render();&#10;        ball.render();&#10;        // Atualiza bricks/explosões e processa colisões dentro do BrickGrid&#10;        float delta = Gdx.graphics.getDeltaTime();&#10;        brickGrid.update(delta, ball, player);&#10;        // depois desenha a grelha atualizada&#10;        brickGrid.render();&#10;&#10;        if (ball.getBoundingBox().overlaps(player.getBoundingBox())) {&#10;            // ajusta direção horizontal consoante o ponto de contacto com o paddle&#10;            ball.adjustDirectionOnContact(player.getBoundingBox());&#10;            ball.reverseYDirection(); // faz a bola “saltar” para cima&#10;        }&#10;&#10;        // Se o jogo ainda não acabou, atualiza normalmente&#10;        if (!gameOver) {&#10;            if (ball.posY() &lt; 0) { // se a bola sair por baixo do ecrã&#10;                gameOver = true;&#10;            }&#10;        }&#10;&#10;        // Se o jogo acabou, mostra o texto no ecrã&#10;        if (gameOver) {&#10;            font.getData().setScale(3); // aumenta o tamanho do texto&#10;            font.draw(batch, &quot;GAME OVER&quot;,&#10;                Gdx.graphics.getWidth() / 2f - 150,&#10;                Gdx.graphics.getHeight() / 2f);&#10;        }&#10;&#10;        // Desenha pontuação no canto superior esquerdo&#10;        font.getData().setScale(1.2f);&#10;        font.draw(batch, &quot;Points: &quot; + brickGrid.getScore(), 10, Gdx.graphics.getHeight() - 10);&#10;&#10;        batch.end();&#10;    }&#10;&#10;    @Override&#10;    public void dispose() {&#10;        batch.dispose();&#10;        font.dispose();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>