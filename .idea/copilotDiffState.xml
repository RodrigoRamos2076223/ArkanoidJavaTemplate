<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Brick.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Brick.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public abstract class Brick {&#10;    protected Animator animator;&#10;    protected int posX, posY;&#10;    protected Rectangle boundingBox;&#10;    protected boolean collided = false;&#10;&#10;    // compatibility constructor (single-frame sprite)&#10;    public Brick(SpriteBatch batch, String spritePath) {&#10;        this(batch, spritePath, 2,1,0,0); // inicializa temporariamente em (0,0)&#10;    }&#10;&#10;    // sprite-sheet aware constructor&#10;    public Brick(SpriteBatch batch, String spritePath, int cols, int rows, int x, int y){&#10;        this.animator = new Animator(batch, spritePath, cols, rows);&#10;        this.posX = x;&#10;        this.posY = y;&#10;        // initialize animator and bounding box immediately&#10;        animator.create();&#10;        int w = Math.max(1, animator.getWidth());&#10;        int h = Math.max(1, animator.getHeight());&#10;        this.boundingBox = new Rectangle(posX, posY, w, h);&#10;    }&#10;&#10;    // Renderiza o brick no ecr達&#10;    public void render() {&#10;        if (boundingBox != null) {&#10;            animator.render(posX, posY, (int) boundingBox.width, (int) boundingBox.height);&#10;        } else {&#10;            animator.render(posX, posY);&#10;        }&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public int getPosX() { return posX; }&#10;    public int getPosY() { return posY; }&#10;&#10;    public boolean isCollided() {&#10;        return collided;&#10;    }&#10;&#10;    // Cada tipo de brick implementa o comportamento da colis達o&#10;    public abstract void onCollision();&#10;&#10;    // Pontos obtidos ao destruir este brick (subclasses podem sobrescrever)&#10;    public int getPoints() { return 0; }&#10;}" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public abstract class Brick {&#10;    protected Animator animator;&#10;    protected int posX, posY;&#10;    protected Rectangle boundingBox;&#10;    protected boolean collided = false;&#10;&#10;    // compatibility constructor (single-frame sprite)&#10;    public Brick(SpriteBatch batch, String spritePath) {&#10;        this(batch, spritePath, 2,1,0,0); // inicializa temporariamente em (0,0)&#10;    }&#10;&#10;    // sprite-sheet aware constructor&#10;    public Brick(SpriteBatch batch, String spritePath, int cols, int rows, int x, int y){&#10;        this.animator = new Animator(batch, spritePath, cols, rows);&#10;        this.posX = x;&#10;        this.posY = y;&#10;        // initialize animator and bounding box immediately&#10;        animator.create();&#10;        int w = Math.max(1, animator.getWidth());&#10;        int h = Math.max(1, animator.getHeight());&#10;        this.boundingBox = new Rectangle(posX, posY, w, h);&#10;    }&#10;&#10;    // Renderiza o brick no ecr達&#10;    public void render() {&#10;        if (boundingBox != null) {&#10;            animator.render(posX, posY, (int) boundingBox.width, (int) boundingBox.height);&#10;        } else {&#10;            animator.render(posX, posY);&#10;        }&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public int getPosX() { return posX; }&#10;    public int getPosY() { return posY; }&#10;&#10;    public boolean isCollided() {&#10;        return collided;&#10;    }&#10;&#10;    // Cada tipo de brick implementa o comportamento da colis達o&#10;    public abstract void onCollision();&#10;&#10;    // Pontos obtidos ao destruir este brick (subclasses podem sobrescrever)&#10;    public int getPoints() { return 0; }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Animator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/game/Animator.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.Animation;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;&#10;public class Animator {&#10;&#10;    // Constant rows and columns of the sprite sheet&#10;    private int FRAME_COLS, FRAME_ROWS;&#10;    // Objects used&#10;    private Animation&lt;TextureRegion&gt; walkAnimation; // Must declare frame type (TextureRegion)&#10;    private Texture walkSheet;&#10;    private SpriteBatch spriteBatch;&#10;    private String path;&#10;    private int width, height;&#10;&#10;    // A variable for tracking elapsed time for the animation&#10;    float stateTime;&#10;&#10;    public Animator(SpriteBatch batch, String path, int columns, int rows) {&#10;        this.spriteBatch = batch;&#10;        this.FRAME_COLS = columns;&#10;        this.FRAME_ROWS = rows;&#10;        this.path = path;&#10;    }&#10;&#10;    public void create() {&#10;&#10;        // Load the sprite sheet as a Texture&#10;        walkSheet = new Texture(Gdx.files.internal(path));&#10;        // Use the split utility method to create a 2D array of TextureRegions. This is&#10;        // possible because this sprite sheet contains frames of equal size and they are&#10;        // all aligned.&#10;        this.width = walkSheet.getWidth() / FRAME_COLS;&#10;        this.height = walkSheet.getHeight() / FRAME_ROWS;&#10;&#10;        TextureRegion[][] tmp = TextureRegion.split(walkSheet,&#10;                walkSheet.getWidth() / FRAME_COLS,&#10;                walkSheet.getHeight() / FRAME_ROWS);&#10;&#10;        // Place the regions into a 1D array in the correct order, starting from the top&#10;        // left, going across first. The Animation constructor requires a 1D array.&#10;        TextureRegion[] walkFrames = new TextureRegion[FRAME_COLS * FRAME_ROWS];&#10;        int index = 0;&#10;        for (int i = 0; i &lt; FRAME_ROWS; i++) {&#10;            for (int j = 0; j &lt; FRAME_COLS; j++) {&#10;                walkFrames[index++] = tmp[i][j];&#10;            }&#10;        }&#10;&#10;        // Initialize the Animation with the frame interval and array of frames&#10;        walkAnimation = new Animation&lt;&gt;(0.095f, walkFrames);&#10;        // time to 0&#10;        stateTime = 0f;&#10;    }&#10;&#10;&#10;    public void render(int posX, int posY) {&#10;        stateTime += Gdx.graphics.getDeltaTime(); // Accumulate elapsed animation time&#10;        // Get current frame of animation for the current stateTime&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY); // Draw current frame at (50, 50)&#10;    }&#10;&#10;    // Overloaded render that scales the frame to provided width/height&#10;    public void render(int posX, int posY, int drawWidth, int drawHeight) {&#10;        stateTime += Gdx.graphics.getDeltaTime();&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY, drawWidth, drawHeight);&#10;    }&#10;&#10;&#10;    public void dispose() { // SpriteBatches and Textures must always be disposed&#10;        walkSheet.dispose();&#10;    }&#10;&#10;    public int getHeight() {&#10;        return height;&#10;    }&#10;&#10;    public int getWidth() {&#10;        return width;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.game;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.Texture;&#10;import com.badlogic.gdx.graphics.g2d.Animation;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.graphics.g2d.TextureRegion;&#10;&#10;public class Animator {&#10;&#10;    // Constant rows and columns of the sprite sheet&#10;    private int FRAME_COLS, FRAME_ROWS;&#10;    // Objects used&#10;    private Animation&lt;TextureRegion&gt; walkAnimation; // Must declare frame type (TextureRegion)&#10;    private Texture walkSheet;&#10;    private SpriteBatch spriteBatch;&#10;    private String path;&#10;    private int width, height;&#10;&#10;    // A variable for tracking elapsed time for the animation&#10;    float stateTime;&#10;&#10;    public Animator(SpriteBatch batch, String path, int columns, int rows) {&#10;        this.spriteBatch = batch;&#10;        this.FRAME_COLS = columns;&#10;        this.FRAME_ROWS = rows;&#10;        this.path = path;&#10;    }&#10;&#10;    public void create() {&#10;&#10;        // Load the sprite sheet as a Texture&#10;        walkSheet = new Texture(Gdx.files.internal(path));&#10;        // Use the split utility method to create a 2D array of TextureRegions. This is&#10;        // possible because this sprite sheet contains frames of equal size and they are&#10;        // all aligned.&#10;        this.width = walkSheet.getWidth() / FRAME_COLS;&#10;        this.height = walkSheet.getHeight() / FRAME_ROWS;&#10;&#10;        TextureRegion[][] tmp = TextureRegion.split(walkSheet,&#10;                walkSheet.getWidth() / FRAME_COLS,&#10;                walkSheet.getHeight() / FRAME_ROWS);&#10;&#10;        // Place the regions into a 1D array in the correct order, starting from the top&#10;        // left, going across first. The Animation constructor requires a 1D array.&#10;        TextureRegion[] walkFrames = new TextureRegion[FRAME_COLS * FRAME_ROWS];&#10;        int index = 0;&#10;        for (int i = 0; i &lt; FRAME_ROWS; i++) {&#10;            for (int j = 0; j &lt; FRAME_COLS; j++) {&#10;                walkFrames[index++] = tmp[i][j];&#10;            }&#10;        }&#10;&#10;        // Initialize the Animation with the frame interval and array of frames&#10;        walkAnimation = new Animation&lt;&gt;(0.095f, walkFrames);&#10;        // time to 0&#10;        stateTime = 0f;&#10;    }&#10;&#10;&#10;    public void render(int posX, int posY) {&#10;        stateTime += Gdx.graphics.getDeltaTime(); // Accumulate elapsed animation time&#10;        // Get current frame of animation for the current stateTime&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY); // Draw current frame at (50, 50)&#10;    }&#10;&#10;    // Overloaded render that scales the frame to provided width/height&#10;    public void render(int posX, int posY, int drawWidth, int drawHeight) {&#10;        stateTime += Gdx.graphics.getDeltaTime();&#10;        TextureRegion currentFrame = walkAnimation.getKeyFrame(stateTime, true);&#10;        spriteBatch.draw(currentFrame, posX, posY, drawWidth, drawHeight);&#10;    }&#10;&#10;&#10;    public void dispose() { // SpriteBatches and Textures must always be disposed&#10;        walkSheet.dispose();&#10;    }&#10;&#10;    public int getHeight() {&#10;        return height;&#10;    }&#10;&#10;    public int getWidth() {&#10;        return width;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>