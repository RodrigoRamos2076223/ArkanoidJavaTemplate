<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Ball.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/Ball.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public class Ball {&#10;    private Animator animator;&#10;    private int posX, posY;&#10;    private Rectangle boundingBox;&#10;    private int directionX;&#10;    private int directionY;&#10;    private double angle;&#10;    private int speedX = 7; // aumenta para a bola ficar mais rápida horizontalmente&#10;    private int speedY = 5;&#10;&#10;&#10;    public Ball(SpriteBatch batch){&#10;&#10;        animator = new Animator(batch, &quot;ball.png&quot;, 2, 2);&#10;        this.directionX =1;&#10;        this.directionY =1;&#10;        this.angle =0;&#10;&#10;    }&#10;&#10;    public void create() {&#10;        animator.create();&#10;        posX = (Gdx.graphics.getWidth()/2) - this.animator.getWidth()/2;&#10;        posY = (Gdx.graphics.getHeight()/2);&#10;        boundingBox = new Rectangle(posX, posY, animator.getWidth(), animator.getHeight());&#10;&#10;    }&#10;&#10;    public void render(){&#10;&#10;        posY+=(directionY* speedY);&#10;        posX+=(speedX * directionX);&#10;&#10;        if (posY &gt; Gdx.graphics.getHeight() - animator.getHeight()) {&#10;            directionY = -1;&#10;        }&#10;&#10;        if (posX &gt; Gdx.graphics.getWidth() - animator.getWidth()) {&#10;            directionX = -1;&#10;        } else if (posX &lt; 0) {&#10;            directionX = 1;&#10;        }&#10;&#10;&#10;        boundingBox.setPosition(posX, posY);&#10;        animator.render(posX,posY);&#10;    }&#10;    public int posY() {&#10;        return posY;&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public void reverseYDirection() {&#10;        directionY *= -1;&#10;    }&#10;&#10;    // Ajusta a direção horizontal dependendo do ponto de contacto no rect (paddle ou brick)&#10;    // Versão simples: calcula um offset normalizado (-1 = totalmente à esquerda, +1 = totalmente à direita)&#10;    // e define directionX e speedX proporcionalmente. Não usa vetores.&#10;    public void adjustDirectionOnContact(Rectangle rect) {&#10;        // centro da bola em X&#10;        float ballCenterX = posX + animator.getWidth() / 2f;&#10;        // posição relativa dentro do rect (0.0 = esquerda, 1.0 = direita)&#10;        float relative = (ballCenterX - rect.x) / rect.width;&#10;        // normaliza para -1 .. 1 (centro = 0)&#10;        float offset = (relative - 0.5f) * 2f;&#10;&#10;        // limiar para considerar como &quot;centro&quot; (sem desvio horizontal)&#10;        float deadZone = 0.20f; // 20% ao centro&#10;        if (Math.abs(offset) &lt;= deadZone) {&#10;            directionX = 0;&#10;            speedX = 0; // movimento vertical&#10;            return;&#10;        }&#10;&#10;        // define a direção (sinal do offset)&#10;        directionX = offset &gt; 0 ? 1 : -1;&#10;&#10;        // velocidade horizontal proporcional à distância do centro (mínimo 1, máximo 6)&#10;        int max = 6;&#10;        int min = 1;&#10;        int calculated = Math.round((Math.abs(offset) - deadZone) / (1f - deadZone) * max);&#10;        speedX = Math.max(min, Math.min(max, calculated));&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;import com.badlogic.gdx.math.Rectangle;&#10;import pt.uma.tpsi.ad.game.Animator;&#10;&#10;public class Ball {&#10;    private Animator animator;&#10;    private int posX, posY;&#10;    private Rectangle boundingBox;&#10;    private int directionX;&#10;    private int directionY;&#10;    private double angle;&#10;    private int speedX = 7; // aumenta para a bola ficar mais rápida horizontalmente&#10;    private int speedY = 5;&#10;&#10;&#10;    public Ball(SpriteBatch batch){&#10;&#10;        animator = new Animator(batch, &quot;ball.png&quot;, 2, 2);&#10;        this.directionX =1;&#10;        this.directionY =1;&#10;        this.angle =0;&#10;&#10;    }&#10;&#10;    public void create() {&#10;        animator.create();&#10;        posX = (Gdx.graphics.getWidth()/2) - this.animator.getWidth()/2;&#10;        posY = (Gdx.graphics.getHeight()/2);&#10;        boundingBox = new Rectangle(posX, posY, animator.getWidth(), animator.getHeight());&#10;&#10;    }&#10;&#10;    public void render(){&#10;&#10;        posY+=(directionY* speedY);&#10;        posX+=(speedX * directionX);&#10;&#10;        if (posY &gt; Gdx.graphics.getHeight() - animator.getHeight()) {&#10;            directionY = -1;&#10;        }&#10;&#10;        if (posX &gt; Gdx.graphics.getWidth() - animator.getWidth()) {&#10;            directionX = -1;&#10;        } else if (posX &lt; 0) {&#10;            directionX = 1;&#10;        }&#10;&#10;&#10;        boundingBox.setPosition(posX, posY);&#10;        animator.render(posX,posY);&#10;    }&#10;    public int posY() {&#10;        return posY;&#10;    }&#10;&#10;    public Rectangle getBoundingBox() {&#10;        return boundingBox;&#10;    }&#10;&#10;    public void reverseYDirection() {&#10;        directionY *= -1;&#10;    }&#10;&#10;    // Empurra a bola para fora do rect fornecido para evitar deteção repetida de colisão&#10;    public void resolveCollisionWith(Rectangle rect) {&#10;        if (animator == null || boundingBox == null) return;&#10;        float ballCenterY = posY + animator.getHeight() / 2f;&#10;        float rectCenterY = rect.y + rect.height / 2f;&#10;        if (ballCenterY &lt; rectCenterY) {&#10;            // bola estava abaixo do rect, posiciona-a abaixo&#10;            posY = (int) (rect.y - animator.getHeight() - 1);&#10;        } else {&#10;            // bola estava acima do rect, posiciona-a acima&#10;            posY = (int) (rect.y + rect.height + 1);&#10;        }&#10;        boundingBox.setPosition(posX, posY);&#10;    }&#10;&#10;    // Ajusta a direção horizontal dependendo do ponto de contacto no rect (paddle ou brick)&#10;    // Versão simples: calcula um offset normalizado (-1 = totalmente à esquerda, +1 = totalmente à direita)&#10;    // e define directionX e speedX proporcionalmente. Não usa vetores.&#10;    public void adjustDirectionOnContact(Rectangle rect) {&#10;        // centro da bola em X&#10;        float ballCenterX = posX + animator.getWidth() / 2f;&#10;        // posição relativa dentro do rect (0.0 = esquerda, 1.0 = direita)&#10;        float relative = (ballCenterX - rect.x) / rect.width;&#10;        // normaliza para -1 .. 1 (centro = 0)&#10;        float offset = (relative - 0.5f) * 2f;&#10;&#10;        // limiar para considerar como &quot;centro&quot; (sem desvio horizontal)&#10;        float deadZone = 0.20f; // 20% ao centro&#10;        if (Math.abs(offset) &lt;= deadZone) {&#10;            directionX = 0;&#10;            speedX = 0; // movimento vertical&#10;            return;&#10;        }&#10;&#10;        // define a direção (sinal do offset)&#10;        directionX = offset &gt; 0 ? 1 : -1;&#10;&#10;        // velocidade horizontal proporcional à distância do centro (mínimo 1, máximo 6)&#10;        int max = 6;&#10;        int min = 1;&#10;        int calculated = Math.round((Math.abs(offset) - deadZone) / (1f - deadZone) * max);&#10;        speedX = Math.max(min, Math.min(max, calculated));&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/BrickGrid.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/java/pt/uma/tpsi/ad/entities/BrickGrid.java" />
              <option name="originalContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Random;&#10;&#10;public class BrickGrid {&#10;&#10;    private final List&lt;Brick&gt; bricks;&#10;    private final List&lt;Explosion&gt; explosions;&#10;    private final SpriteBatch batch;&#10;&#10;    private static final int ROWS = 4;&#10;    private static final int COLS = 20;&#10;&#10;    public BrickGrid(SpriteBatch batch) {&#10;        this.batch = batch;&#10;        this.bricks = new ArrayList&lt;&gt;();&#10;        this.explosions = new ArrayList&lt;&gt;();&#10;        createBricks();&#10;    }&#10;&#10;    private void createBricks() {&#10;        Random rng = new Random();&#10;&#10;        int brickW = 32;&#10;        int brickH = 16;&#10;        int spacingX = 20;&#10;        int spacingY = 13;&#10;&#10;        int totalWidth = COLS * (brickW + spacingX) - spacingX;&#10;        int startX = (Gdx.graphics.getWidth() - totalWidth) / 2;&#10;        int startY = Gdx.graphics.getHeight() - 100;&#10;&#10;        bricks.clear();&#10;&#10;        for (int row = 0; row &lt; ROWS; row++) {&#10;            for (int col = 0; col &lt; COLS; col++) {&#10;                float p = rng.nextFloat();&#10;                Brick b;&#10;&#10;                if (p &lt; 0.6f) {&#10;                    b = new NormalBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.8f) {&#10;                    b = new StrongBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.9f) {&#10;                    b = new IndestructibleBrick(batch, 0, 0);&#10;                } else {&#10;                    b = new PowerUpBrick(batch, 0, 0);&#10;                }&#10;&#10;                int x = startX + col * (brickW + spacingX);&#10;                int y = startY - row * (brickH + spacingY);&#10;&#10;                b.posX = x;&#10;                b.posY = y;&#10;                b.getBoundingBox().setPosition(x, y);&#10;&#10;                bricks.add(b);&#10;            }&#10;        }&#10;    }&#10;&#10;    /** Atualiza colisões e explosões */&#10;    public void update(float delta, Ball ball) {&#10;        // Checa colisões entre bola e bricks usando um ciclo indexado (reverse) para permitir remoção&#10;        for (int i = bricks.size() - 1; i &gt;= 0; i--) {&#10;            Brick brick = bricks.get(i);&#10;            if (brick.getBoundingBox().overlaps(ball.getBoundingBox())) {&#10;                // processa colisão&#10;                brick.onCollision();&#10;&#10;                // inverte a direção da bola uma vez por colisão&#10;                ball.reverseYDirection();&#10;&#10;                // se o brick foi destruído com este impacto, cria explosão e remove o brick&#10;                if (brick.isCollided()) {&#10;                    int explosionX = brick.getPosX();&#10;                    int explosionY = brick.getPosY();&#10;                    int w = (int) brick.getBoundingBox().width;&#10;                    int h = (int) brick.getBoundingBox().height;&#10;                    explosions.add(new Explosion(batch, explosionX, explosionY, w, h));&#10;                    bricks.remove(i);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Atualiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.update(delta);&#10;        }&#10;&#10;        // Remove explosões concluídas&#10;        explosions.removeIf(Explosion::shouldRemove);&#10;    }&#10;&#10;    /** Renderiza bricks e explosões */&#10;    public void render() {&#10;        // Renderiza bricks ainda não destruídos&#10;        for (Brick brick : bricks) {&#10;            if (!brick.isCollided()) {&#10;                brick.render();&#10;            }&#10;        }&#10;&#10;        // Renderiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.render();&#10;        }&#10;    }&#10;&#10;    public List&lt;Brick&gt; getBricks() {&#10;        return bricks;&#10;    }&#10;&#10;    public List&lt;Explosion&gt; getExplosions() {&#10;        return explosions;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package pt.uma.tpsi.ad.entities;&#10;&#10;import com.badlogic.gdx.Gdx;&#10;import com.badlogic.gdx.graphics.g2d.SpriteBatch;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Random;&#10;&#10;public class BrickGrid {&#10;&#10;    private final List&lt;Brick&gt; bricks;&#10;    private final List&lt;Explosion&gt; explosions;&#10;    private final SpriteBatch batch;&#10;&#10;    private static final int ROWS = 4;&#10;    private static final int COLS = 20;&#10;&#10;    public BrickGrid(SpriteBatch batch) {&#10;        this.batch = batch;&#10;        this.bricks = new ArrayList&lt;&gt;();&#10;        this.explosions = new ArrayList&lt;&gt;();&#10;        createBricks();&#10;    }&#10;&#10;    private void createBricks() {&#10;        Random rng = new Random();&#10;&#10;        int brickW = 32;&#10;        int brickH = 16;&#10;        int spacingX = 20;&#10;        int spacingY = 13;&#10;&#10;        int totalWidth = COLS * (brickW + spacingX) - spacingX;&#10;        int startX = (Gdx.graphics.getWidth() - totalWidth) / 2;&#10;        int startY = Gdx.graphics.getHeight() - 100;&#10;&#10;        bricks.clear();&#10;&#10;        for (int row = 0; row &lt; ROWS; row++) {&#10;            for (int col = 0; col &lt; COLS; col++) {&#10;                float p = rng.nextFloat();&#10;                Brick b;&#10;&#10;                if (p &lt; 0.6f) {&#10;                    b = new NormalBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.8f) {&#10;                    b = new StrongBrick(batch, 0, 0);&#10;                } else if (p &lt; 0.9f) {&#10;                    b = new IndestructibleBrick(batch, 0, 0);&#10;                } else {&#10;                    b = new PowerUpBrick(batch, 0, 0);&#10;                }&#10;&#10;                int x = startX + col * (brickW + spacingX);&#10;                int y = startY - row * (brickH + spacingY);&#10;&#10;                b.posX = x;&#10;                b.posY = y;&#10;                b.getBoundingBox().setPosition(x, y);&#10;&#10;                bricks.add(b);&#10;            }&#10;        }&#10;    }&#10;&#10;    /** Atualiza colisões e explosões */&#10;    public void update(float delta, Ball ball) {&#10;        // Checa colisões entre bola e bricks usando um ciclo indexado (reverse) para permitir remoção&#10;        for (int i = bricks.size() - 1; i &gt;= 0; i--) {&#10;            Brick brick = bricks.get(i);&#10;            if (brick.getBoundingBox().overlaps(ball.getBoundingBox())) {&#10;                // processa colisão&#10;                brick.onCollision();&#10;&#10;                // inverte a direção da bola uma vez por colisão&#10;                ball.reverseYDirection();&#10;&#10;                // empurra a bola para fora do brick para evitar colisões repetidas&#10;                ball.resolveCollisionWith(brick.getBoundingBox());&#10;&#10;                // se o brick foi destruído com este impacto, cria explosão e remove o brick&#10;                if (brick.isCollided()) {&#10;                    int explosionX = brick.getPosX();&#10;                    int explosionY = brick.getPosY();&#10;                    int w = (int) brick.getBoundingBox().width;&#10;                    int h = (int) brick.getBoundingBox().height;&#10;                    explosions.add(new Explosion(batch, explosionX, explosionY, w, h));&#10;                    bricks.remove(i);&#10;                }&#10;            }&#10;        }&#10;&#10;        // Atualiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.update(delta);&#10;        }&#10;&#10;        // Remove explosões concluídas&#10;        explosions.removeIf(Explosion::shouldRemove);&#10;    }&#10;&#10;    /** Renderiza bricks e explosões */&#10;    public void render() {&#10;        // Renderiza bricks ainda não destruídos&#10;        for (Brick brick : bricks) {&#10;            if (!brick.isCollided()) {&#10;                brick.render();&#10;            }&#10;        }&#10;&#10;        // Renderiza explosões&#10;        for (Explosion e : explosions) {&#10;            e.render();&#10;        }&#10;    }&#10;&#10;    public List&lt;Brick&gt; getBricks() {&#10;        return bricks;&#10;    }&#10;&#10;    public List&lt;Explosion&gt; getExplosions() {&#10;        return explosions;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>